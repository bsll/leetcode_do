#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Time    : 2025/04/25 09:39:33
# Author  : AI-NLP-WangXiaohui
# File    : q_lcr_185_statisticsProbability.py
'''

代码
测试用例
测试结果
测试结果
LCR 185. 统计结果概率
已解答
中等
相关标签
相关企业
你选择掷出 num 个色子，请返回所有点数总和的概率。

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 num 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

示例 1：

输入：num = 3
输出：[0.00463,0.01389,0.02778,0.04630,0.06944,0.09722,0.11574,0.12500,0.12500,0.11574,0.09722,0.06944,0.04630,0.02778,0.01389,0.00463]
示例 2：

输入：num = 5
输出:[0.00013,0.00064,0.00193,0.00450,0.00900,0.01620,0.02636,0.03922,0.05401,0.06944,0.08372,0.09452,0.10031,0.10031,0.09452,0.08372,0.06944,0.05401,0.03922,0.02636,0.01620,0.00900,0.00450,0.00193,0.00064,0.00013]
 

提示：

1 <= num <= 11
'''
'''
思路: 动态规划 dp2[j+k] = dp2[j+k] + dp1[j] / 6.0 ,k in [0,5]
'''
class Solution(object):
    def statisticsProbability(self, num):
        """
        :type num: int
        :rtype: List[float]
        """
        dp1 = [1/6] * 6
        # 从 2 个骰子开始，逐步计算到 n 个骰子。
        for i in range(2,num+1):
            # 长度为 5i + 1，对应 i 个骰子的可能和数量。
            dp2 = [0] * (5 * i + 1)
            # 遍历前 i-1 个骰子的所有可能和（dp1 的索引 j）。
            for j in range(len(dp1)):
                for k in range(6):
                    # 对于每个可能的旧和 j，
                    # 新增骰子的点数 k+1（k 为 0-5），
                    # 将概率累加到 dp2[j+k]。
                    dp2[j+k] = dp2[j+k] + dp1[j] / 6.0
            dp1 = dp2
        return dp1
sou = Solution()
print(sou.statisticsProbability(2))